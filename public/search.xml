<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java8流相关Stream]]></title>
    <url>%2F2018%2F07%2F24%2F%20java8%E6%B5%81%E7%9B%B8%E5%85%B3Stream%2F</url>
    <content type="text"><![CDATA[最近去了新公司，发现里面的循环什么的基本都是用stream来写的。就是java8那个流，感觉这种写法优雅，易懂，非常方便，所以在此学习并且记录下来。希望对Stream有一个大体上的认识。 简介:一个宏观上的介绍：流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。元素流在管道中经过中间操作(intermediate operation)的处理，最后由最终操作(terminal operation)得到前面处理的结果。 流管道示意图: 流的操作分为两种：中间操作方法：像filter这种，返回流对象本身，最终不产生新集合的方法。最终操作方法：像count这种最终会从stream产生值的方法。 两个基础特性： Pipelining ：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格。这样可以对操作进行优化，比如延迟执行和短路。 内部迭代 ：以前对集合的遍历都是通过Iterator或者For-each的方式，显示的在集合外部进行迭代，这叫做外部迭代，Stream提供了内部迭代的方式，通过访问者模式实现。 为什么不在集合类实现这些操作，而是定义了全新的Stream API？Oracle官方给出了几个重要原因：一是集合类持有的所有元素都是存储在内存中的，非常巨大的集合类会占用大量的内存，而Stream的元素却是在访问的时候才被计算出来，这种“延迟计算”的特性有点类似Clojure的lazy-seq，占用内存很少。二是集合类的迭代逻辑是调用者负责，通常是for循环，而Stream的迭代是隐含在对Stream的各种操作中，例如map()。 一、创建Stream数据源流的来源。可以是集合，数组，I/O channel，产生器generator等。(Map不能作为Stream的源) 12345678910111213// 1.Individual valuesStream&lt;String&gt; s = Stream.of("a", "b", "c");// 2. ArraysString [] strArray = new String[] &#123;"a", "b", "c"&#125;;Stream&lt;String&gt; arrs = Stream.of(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);Stream&lt;String&gt; lists = list.stream();// 4. iterate Stream.iterate(0, n -&gt; n + 3).limit(10).forEach(x -&gt; System.out.print(x + " ")); // 0 3 6 9 12 15 18 21 24 27// 5. generate//将一个无限的stream限制在10个"test"字符串String joinStr = Stream.generate(() -&gt; "test").limit(10).collect(Collectors.joining(",")); stream:集合创建串行流 12List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); parallelStream:集合创建并行流 12List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");List&lt;String&gt; filtered = strings.parallelStream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); 二、中间操作distinct:去除重复123List&lt;String&gt; lists = Arrays.asList("1", "2", "3", "3", "follow","wind", "followwwind");lists.stream().distinct().forEach(p -&gt; System.out.print(p + "\t")); //lists.stream().distinct().forEach(p -&gt; System.out.print(System.out::println); filter:过滤元素，返回过滤条件通过的流。1lists.stream().filter(p -&gt; p.length() &gt; 1).forEach(p -&gt; System.out.print(p + "\t")); sorted:流排序，中间操作返回流本身。12345678910lists.stream().filter(str -&gt; str.contains("w")) .sorted((str1, str2) -&gt; &#123; if (str1.length() == str2.length()) &#123; return 0; &#125; else if (str1.length() &gt; str2.length()) &#123; return 1; &#125; else &#123; return -1; &#125; &#125;).forEach(System.out::println); limint:获取截取的前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素。1lists.stream().limit(5).forEach(p -&gt; System.out.print(p + "\t")); skip:返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream。1lists.stream().skip(5).forEach(p -&gt; System.out.print(p + "\t")); peek:生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数。1lists.stream().peek(p -&gt; &#123;p = p.toUpperCase(); System.out.println(p);&#125;).forEach(System.out::println); map:接受lambda ,将元素转换成其他形式或提取信息。接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素12345678910lists.stream().map(p -&gt; p + "--&gt;").forEach(System.out::print); lists.stream().map(p -&gt; p.split("")).map(p -&gt; &#123; String tmp = ""; if(p.length &gt; 1)&#123; tmp = p[1]; &#125;else&#123; tmp = p[0]; &#125; return tmp + "\t"; &#125;).forEach(System.out::print); flatMap:和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中1234567891011lists.stream().flatMap(p -&gt; Stream.of(p.split("www"))).forEach(p -&gt; System.out.print(p + "\t"));//看看使用flatMap和不用faltMap输出结果的异同。Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) ); System.out.println(); Stream&lt;Integer&gt; outputStream = inputStream. flatMap((childList) -&gt; childList.stream()); outputStream.forEach(p -&gt; System.out.print(p + "\t")); 三、最终操作forEach:每个元素匹配1lists.stream().forEach(System.out::print); match:流匹配，终结操作123System.out.println(lists.stream().allMatch(str -&gt; str.length() == 3));System.out.println(lists.stream().anyMatch(str -&gt; str.length() &gt; 5));System.out.println(lists.stream().noneMatch(str -&gt; str.length() &gt; 5)); count:1System.out.println(lists.stream().count()); reduce:可以将流中元素反复结合起来，得到一个值。可以设置一个初始值。123Optional&lt;String&gt; reOptional = lists.stream().reduce((str, str2) -&gt; str + "--&gt;" + str2);reOptional.ifPresent(System.out::println); //lists.stream().filter(p -&gt; p.matches("\\d+")).mapToInt(p -&gt; Integer.valueOf(p)).reduce(Integer::sum).ifPresent(System.out::println); collect:收集。将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法12345List&lt;String&gt; ll = lists.stream().collect(Collectors.toList());lists.stream().collect(Collectors.maxBy((p1, p2) -&gt; p1.compareTo(p2))).ifPresent(System.out::println); lists.stream().collect(Collectors.minBy((p1, p2) -&gt; p1.compareTo(p2))).ifPresent(System.out::println); int s = lists.stream().filter(p -&gt; p.matches("\\d+")).collect(Collectors.summingInt(p -&gt; Integer.valueOf(p)));String liString = lists.stream().collect(Collectors.joining(",")); sum:做求和汇总1lists.stream().filter(p -&gt; p.matches("\\d+")).mapToInt(p -&gt; Integer.valueOf(p)).sum(); findFirst:查找第一个123Optional&lt;String&gt; firstOptional = lists.stream().findFirst();firstOptional.ifPresent(System.out::println);Stream.of().findFirst().ifPresent(System.out::println); findAny:查找随机一个1lists.stream().findAny().ifPresent(System.out::println); Collectors:将流转化为集合和聚合元素。可以返回列表或者字符串123456List&lt;String&gt;strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println("筛选列表: " + filtered);String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", "));System.out.println("合并字符串: " + mergedString); summaryStatistics:统计，主要作用于int、double、long等类型上，产生各种统计结果123456List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println("列表中最大的数 : " + stats.getMax());System.out.println("列表中最小的数 : " + stats.getMin());System.out.println("所有数之和 : " + stats.getSum());System.out.println("平均数 : " + stats.getAverage()); 分区，分组，多级分组:进阶，高级，复杂操作，暂且略去。 参考文献：1.https://blog.csdn.net/dongyuancaizi/article/details/787959452.http://www.runoob.com/java/java8-streams.html3.https://blog.csdn.net/followwwind/article/details/782113954.https://www.liaoxuefeng.com/article/001411309538536a1455df20d284b81a7bfa2f91db0f223000]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的性能优化总结]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、Web前端性能优化 浏览器访问优化 减少http请求，主要是合并css，合并js，合并图片，浏览器一次访问的js，css合并成一个文件，多张图片合并成一张，如果每张图片有不通的超链接，可通过css偏移响应鼠标点击操作，构造不通的URL 。 使用浏览器缓存，通过设置http头中的Cache-Control 和 Expires 的属性，可以缓存js，css，logo，图标这种更新频率比较低的静态资源，并设置缓存天数。如果静态资源文件变化需要及时的应用到客户端浏览器的时候可以通过改变文件名来实现，即更新一个文件而不是更新文件的内容。 启用压缩，在服务器端对文件压缩，在浏览器对文件进行解压缩。可以对html，css，js文件启用GZip压缩可达到较好的效果。 CSS放在页面的最上面，JS放在页面最下面。css直接渲染，js会执行，如果时间长会阻塞整个页面，造成缓慢。 减少Cookie的传输。静态资源的访问，可以使用独立域名访问，避免请求静态资源时发送cookie。 CDN加速 反向代理，通过配置缓存的功能加速web请求。负载均衡，也可以热门信息缓存在反向代理服务器上，如果更新的话就通知缓存失效。 二、应用服务器性能优化，主要有缓存，集群，异步等。 分布式缓存，缓存可以存在浏览器，应用服务器和数据库服务器中。既可以对数据缓存，也可以对文件进行缓存，还可以对页面片段进行缓存。 缓存的基本原理，缓存就是将数据存储在相对较高访问速度的存储介质中 合理使用缓存，一般来说数据的读写比为2：1以上使用缓存才有意义。缓存系统启动时就把热点数据加载好，这个缓存预加载手段叫做缓存预热。缓存穿透，一个简单的对策是将不存在的数据也缓存起来。 分布式缓存架构。应用程序通过一致性hash等路由算法选择缓存服务器远程访问缓存数据，缓存服务器之间不通信。 Memcached，分布式服务器远程通信需要考虑两方面的要素，一个是通信协议，一个是通信序列化协议。 异步操作 加入消息队列，消息队列既能解耦，又能削峰。将短时间宝并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 使用集群 使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问骑牛分发到多台服务器上处理。避免单一服务器因负载压力过大而相应缓慢。 代码优化 多线程处理，线程安全解决办法，1.将对象设计成无状态，这样在多线程并发访问的时候就不会出现状态不一致的情况，servlet对象的设计为无状态的对象。web开发中常用的贫血模型对象都是无状态对象，不过从面向对象的设计角度看的话，无状态对象是一种不良的设计。2.使用局部对象。3.加锁 资源复用。减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程，复杂对象等。资源复用主要有两种模式：单例和对象池。 数据结构。一般的Hash算法是Time33算法，对字符串逐字符迭代乘以33，求得Hash值，hash(i) = hash(i-1) * 33 + str[i] 比如 AA 的 hashcode 是2210 AB的hashcode 是2211 。一个可行的方案是对字符串取信息指纹，再对信息求hashcode，原始字符串-&gt;MD5-&gt;hash计算 垃圾回收 三、存储性能优化 ​ B+树和LSM树：一般的NoSql产品采用LSM树作为主要的数据结构。LSM树可以看做是一个N阶合并树。 ​ RAID vs HDFS：HDFS以块为单位管理文件内容，一个文件被分割成若干个Block。每写完一个Block，HDFS就将其自动复制到另外两台机器上，保证每个Block有三个副本。当对文件进行处理计算时，通过MapReduce并发计算任务框架，启动多个计算子任务。]]></content>
      <categories>
        <category>架构相关</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[最近看了马士兵老师讲的并发课程，讲到这个例子的时候提出两个问题，现在自己经过反思消化，记录下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.LinkedList;import java.util.concurrent.TimeUnit;/** * Description:一个普通的生产者和消费者的例子 * @author xiudongxu * @date 2018/4/22 */public class ProducerAndConsumer &#123; final private LinkedList list = new LinkedList(); //存储容器 final private int MAX = 10; //元素最大个数 private int count = 0; public synchronized void put(Object obj)&#123; //问题1：这里为啥用while而不是if //假设有两个线程t1,t2在同时在wait处等待，而且容器此时突然有了一个空位置，而且已经被刚刚消费了的线程使用notifyall()唤醒了， //t1，t2接收到唤醒操作时，同时去获取对象锁，此时假设t2获取成功了。t2 添加一个元素，此时容器满了，t2线程使用notifyall唤醒t1线程。 //t1去获取对象锁，从this.wait()处继续执行代码。如果此时使用的是if 那么就出问题了，t1直接执行add操作，导致容器超出容量，报错。 //而如果是while循环的话，那么还会进行一次list.size() == MAX 判断。 //判断结束t1 又会wait 而释放锁。等待被唤醒添加元素。 //这样就不会出问题了。 //当然以上描述比较复杂，是因为要出现这种错误的话，需要天时地利人和， //但是这种极端的情况又必须要考虑好，才能保证万无一失。所以说这个经典问题是值得反复推敲的。 //而且《effective java》 中也说到 一般wait都要与while配合使用，如果不懂就记住。 while (list.size() == MAX)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(obj); ++count; //问题2：为何用notifyall 而不是 notify //注：唤醒 是指线程的状态 从等待的状态变成就绪的状态。 //假设此时是有一个生产者线程，一个消费者线程在等待的状态。 //如果使用notify 唤醒的是一个生产者线程。那么就死锁等待了。所有的线程都是等待状态就死锁了。 //如果是notify 唤醒的是所有线程，即使是一个生产者线程，那么生产者线程等待失去锁的时候，消费者线程从就绪态获得锁会继续执行消费，而不是程序进入死锁的状态。 this.notifyAll(); &#125; public synchronized Object get()&#123; Object obj = null; while (list.size() == 0)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; obj = list.removeFirst(); -- count; this.notifyAll(); return obj; &#125; public static void main(String[] args) &#123; ProducerAndConsumer pandc = new ProducerAndConsumer(); //启动消费者线程 for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.println(pandc.get()); &#125; &#125;,"consumer" + i).start(); &#125; //睡一会 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //启动生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 25; j++) &#123; pandc.put(Thread.currentThread().getName() + " " + j); &#125; &#125;,"producter" + i).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建自己的博客]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[万事都有因想要搭建博客已经有很长时间了，虽然我觉得码字是件很麻烦的事情，但是很多前辈又说过，经常记录对自己的成长是有帮助的。所以万事开头难，一切慢慢练习，好好坚持。希望这是一个长期而且有意义的事情。 女票现在经常写点评，而且有的点评阅读量在几万以上，这么多阅读量我是很震惊的，她一般都是长文，字很多，图为并茂的那种，基本是每个菜品配图，配评论，然后总结一下服务、环境、价格、推荐指数等等。这样细致的点评也难怪经常被人点赞，经常被商家点赞。所以我要学习这种经常点评，总结的精神，就从现在开始吧。 因-&gt;果自从上一次搭建自己的博客是在17年的国庆假期，当时使用的是Jekyll,后来因为要调整的东西太多啦，就中途废止了。这次使用Hexo搭建了博客，感觉后者操作还是比较方便的，选用的主题也是自己比较中意的NexT。当然创建过程还算比较顺利的原因是得益于参考了很多先人的博客，多亏这个博客为我铺平道路，抱拳感谢~ 修改样式变得酷炫参考了这个博客，这位大神讲解的很细致，但是有几个点是不起效果的，而且因为我的版本是6.0.1 所以有些操作是不同的。 当然，经过仔细研究还是能解决的，毕竟也是研究代码的人，这个模板的套路摸清了就好搞啦~ 需要有点耐心奥。 搞了一晚上的样式，，有些已经实现，但是还有些不太完美，只能后续再进行了。 TODO List: 在线沟通 邀请码：0f81ff2f Travis CI 自动发布 参考链接：传送门 友情链接、图片文章 参考链接：传送门 附加今日发现的好玩的网站： easyicon ：一个图标网站。 JiaThis ：一个可以嵌入分享、评论、推荐按钮的功能的网站。 iissnan ：NexT作者的博客]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>个人记录</tag>
      </tags>
  </entry>
</search>
