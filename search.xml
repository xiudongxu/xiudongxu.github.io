<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[生产者消费者]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[最近看了马士兵老师讲的并发课程，讲到这个例子的时候提出两个问题，现在自己经过反思消化，记录下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.LinkedList;import java.util.concurrent.TimeUnit;/** * Description:一个普通的生产者和消费者的例子 * @author xiudongxu * @date 2018/4/22 */public class ProducerAndConsumer &#123; final private LinkedList list = new LinkedList(); //存储容器 final private int MAX = 10; //元素最大个数 private int count = 0; public synchronized void put(Object obj)&#123; //问题1：这里为啥用while而不是if //假设有两个线程t1,t2在同时在wait处等待，而且容器此时突然有了一个空位置，而且已经被刚刚消费了的线程使用notifyall()唤醒了， //t1，t2接收到唤醒操作时，同时去获取对象锁，此时假设t2获取成功了。t2 添加一个元素，此时容器满了，t2线程使用notifyall唤醒t1线程。 //t1去获取对象锁，从this.wait()处继续执行代码。如果此时使用的是if 那么就出问题了，t1直接执行add操作，导致容器超出容量，报错。 //而如果是while循环的话，那么还会进行一次list.size() == MAX 判断。 //判断结束t1 又会wait 而释放锁。等待被唤醒添加元素。 //这样就不会出问题了。 //当然以上描述比较复杂，是因为要出现这种错误的话，需要天时地利人和， //但是这种极端的情况又必须要考虑好，才能保证万无一失。所以说这个经典问题是值得反复推敲的。 //而且《effective java》 中也说到 一般wait都要与while配合使用，如果不懂就记住。 while (list.size() == MAX)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(obj); ++count; //问题2：为何用notifyall 而不是 notify //注：唤醒 是指线程的状态 从等待的状态变成就绪的状态。 //假设此时是有一个生产者线程，一个消费者线程在等待的状态。 //如果使用notify 唤醒的是一个生产者线程。那么就死锁等待了。所有的线程都是等待状态就死锁了。 //如果是notify 唤醒的是所有线程，即使是一个生产者线程，那么生产者线程等待失去锁的时候，消费者线程从就绪态获得锁会继续执行消费，而不是程序进入死锁的状态。 this.notifyAll(); &#125; public synchronized Object get()&#123; Object obj = null; while (list.size() == 0)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; obj = list.removeFirst(); -- count; this.notifyAll(); return obj; &#125; public static void main(String[] args) &#123; ProducerAndConsumer pandc = new ProducerAndConsumer(); //启动消费者线程 for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.println(pandc.get()); &#125; &#125;,"consumer" + i).start(); &#125; //睡一会 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //启动生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 25; j++) &#123; pandc.put(Thread.currentThread().getName() + " " + j); &#125; &#125;,"producter" + i).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建自己的博客]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[万事都有因想要搭建博客已经有很长时间了，虽然我觉得码字是件很麻烦的事情，但是很多前辈又说过，经常记录对自己的成长是有帮助的。所以万事开头难，一切慢慢练习，好好坚持。希望这是一个长期而且有意义的事情。 女票现在经常写点评，而且有的点评阅读量在几万以上，这么多阅读量我是很震惊的，她一般都是长文，字很多，图为并茂的那种，基本是每个菜品配图，配评论，然后总结一下服务、环境、价格、推荐指数等等。这样细致的点评也难怪经常被人点赞，经常被商家点赞。所以我要学习这种经常点评，总结的精神，就从现在开始吧。 因-&gt;果自从上一次搭建自己的博客是在17年的国庆假期，当时使用的是Jekyll,后来因为要调整的东西太多啦，就中途废止了。这次使用Hexo搭建了博客，感觉后者操作还是比较方便的，选用的主题也是自己比较中意的NexT。当然创建过程还算比较顺利的原因是得益于参考了很多先人的博客，多亏这个博客为我铺平道路，抱拳感谢~ 修改样式变得酷炫参考了这个博客，这位大神讲解的很细致，但是有几个点是不起效果的，而且因为我的版本是6.0.1 所以有些操作是不同的。 当然，经过仔细研究还是能解决的，毕竟也是研究代码的人，这个模板的套路摸清了就好搞啦~ 需要有点耐心奥。 搞了一晚上的样式，，有些已经实现，但是还有些不太完美，只能后续再进行了。 TODO List: 在线沟通 邀请码：0f81ff2f Travis CI 自动发布 参考链接：传送门 友情链接、图片文章 参考链接：传送门 附加今日发现的好玩的网站： easyicon ：一个图标网站。 JiaThis ：一个可以嵌入分享、评论、推荐按钮的功能的网站。 iissnan ：NexT作者的博客]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>个人记录</tag>
      </tags>
  </entry>
</search>
