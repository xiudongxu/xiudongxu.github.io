<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单的性能优化总结]]></title>
    <url>%2F2018%2F05%2F21%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、Web前端性能优化 浏览器访问优化 减少http请求，主要是合并css，合并js，合并图片，浏览器一次访问的js，css合并成一个文件，多张图片合并成一张，如果每张图片有不通的超链接，可通过css偏移响应鼠标点击操作，构造不通的URL 。 使用浏览器缓存，通过设置http头中的Cache-Control 和 Expires 的属性，可以缓存js，css，logo，图标这种更新频率比较低的静态资源，并设置缓存天数。如果静态资源文件变化需要及时的应用到客户端浏览器的时候可以通过改变文件名来实现，即更新一个文件而不是更新文件的内容。 启用压缩，在服务器端对文件压缩，在浏览器对文件进行解压缩。可以对html，css，js文件启用GZip压缩可达到较好的效果。 CSS放在页面的最上面，JS放在页面最下面。css直接渲染，js会执行，如果时间长会阻塞整个页面，造成缓慢。 减少Cookie的传输。静态资源的访问，可以使用独立域名访问，避免请求静态资源时发送cookie。 CDN加速 反向代理，通过配置缓存的功能加速web请求。负载均衡，也可以热门信息缓存在反向代理服务器上，如果更新的话就通知缓存失效。 二、应用服务器性能优化，主要有缓存，集群，异步等。 分布式缓存，缓存可以存在浏览器，应用服务器和数据库服务器中。既可以对数据缓存，也可以对文件进行缓存，还可以对页面片段进行缓存。 缓存的基本原理，缓存就是将数据存储在相对较高访问速度的存储介质中 合理使用缓存，一般来说数据的读写比为2：1以上使用缓存才有意义。缓存系统启动时就把热点数据加载好，这个缓存预加载手段叫做缓存预热。缓存穿透，一个简单的对策是将不存在的数据也缓存起来。 分布式缓存架构。应用程序通过一致性hash等路由算法选择缓存服务器远程访问缓存数据，缓存服务器之间不通信。 Memcached，分布式服务器远程通信需要考虑两方面的要素，一个是通信协议，一个是通信序列化协议。 异步操作 加入消息队列，消息队列既能解耦，又能削峰。将短时间宝并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 使用集群 使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问骑牛分发到多台服务器上处理。避免单一服务器因负载压力过大而相应缓慢。 代码优化 多线程处理，线程安全解决办法，1.将对象设计成无状态，这样在多线程并发访问的时候就不会出现状态不一致的情况，servlet对象的设计为无状态的对象。web开发中常用的贫血模型对象都是无状态对象，不过从面向对象的设计角度看的话，无状态对象是一种不良的设计。2.使用局部对象。3.加锁 资源复用。减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程，复杂对象等。资源复用主要有两种模式：单例和对象池。 数据结构。一般的Hash算法是Time33算法，对字符串逐字符迭代乘以33，求得Hash值，hash(i) = hash(i-1) * 33 + str[i] 比如 AA 的 hashcode 是2210 AB的hashcode 是2211 。一个可行的方案是对字符串取信息指纹，再对信息求hashcode，原始字符串-&gt;MD5-&gt;hash计算 垃圾回收 三、存储性能优化 ​ B+树和LSM树：一般的NoSql产品采用LSM树作为主要的数据结构。LSM树可以看做是一个N阶合并树。 ​ RAID vs HDFS：HDFS以块为单位管理文件内容，一个文件被分割成若干个Block。每写完一个Block，HDFS就将其自动复制到另外两台机器上，保证每个Block有三个副本。当对文件进行处理计算时，通过MapReduce并发计算任务框架，启动多个计算子任务。]]></content>
      <categories>
        <category>架构相关</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%2F</url>
    <content type="text"><![CDATA[最近看了马士兵老师讲的并发课程，讲到这个例子的时候提出两个问题，现在自己经过反思消化，记录下来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.LinkedList;import java.util.concurrent.TimeUnit;/** * Description:一个普通的生产者和消费者的例子 * @author xiudongxu * @date 2018/4/22 */public class ProducerAndConsumer &#123; final private LinkedList list = new LinkedList(); //存储容器 final private int MAX = 10; //元素最大个数 private int count = 0; public synchronized void put(Object obj)&#123; //问题1：这里为啥用while而不是if //假设有两个线程t1,t2在同时在wait处等待，而且容器此时突然有了一个空位置，而且已经被刚刚消费了的线程使用notifyall()唤醒了， //t1，t2接收到唤醒操作时，同时去获取对象锁，此时假设t2获取成功了。t2 添加一个元素，此时容器满了，t2线程使用notifyall唤醒t1线程。 //t1去获取对象锁，从this.wait()处继续执行代码。如果此时使用的是if 那么就出问题了，t1直接执行add操作，导致容器超出容量，报错。 //而如果是while循环的话，那么还会进行一次list.size() == MAX 判断。 //判断结束t1 又会wait 而释放锁。等待被唤醒添加元素。 //这样就不会出问题了。 //当然以上描述比较复杂，是因为要出现这种错误的话，需要天时地利人和， //但是这种极端的情况又必须要考虑好，才能保证万无一失。所以说这个经典问题是值得反复推敲的。 //而且《effective java》 中也说到 一般wait都要与while配合使用，如果不懂就记住。 while (list.size() == MAX)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; list.add(obj); ++count; //问题2：为何用notifyall 而不是 notify //注：唤醒 是指线程的状态 从等待的状态变成就绪的状态。 //假设此时是有一个生产者线程，一个消费者线程在等待的状态。 //如果使用notify 唤醒的是一个生产者线程。那么就死锁等待了。所有的线程都是等待状态就死锁了。 //如果是notify 唤醒的是所有线程，即使是一个生产者线程，那么生产者线程等待失去锁的时候，消费者线程从就绪态获得锁会继续执行消费，而不是程序进入死锁的状态。 this.notifyAll(); &#125; public synchronized Object get()&#123; Object obj = null; while (list.size() == 0)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; obj = list.removeFirst(); -- count; this.notifyAll(); return obj; &#125; public static void main(String[] args) &#123; ProducerAndConsumer pandc = new ProducerAndConsumer(); //启动消费者线程 for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 5; j++) &#123; System.out.println(pandc.get()); &#125; &#125;,"consumer" + i).start(); &#125; //睡一会 try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //启动生产者线程 for (int i = 0; i &lt; 2; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 25; j++) &#123; pandc.put(Thread.currentThread().getName() + " " + j); &#125; &#125;,"producter" + i).start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建自己的博客]]></title>
    <url>%2F2018%2F03%2F31%2F%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[万事都有因想要搭建博客已经有很长时间了，虽然我觉得码字是件很麻烦的事情，但是很多前辈又说过，经常记录对自己的成长是有帮助的。所以万事开头难，一切慢慢练习，好好坚持。希望这是一个长期而且有意义的事情。 女票现在经常写点评，而且有的点评阅读量在几万以上，这么多阅读量我是很震惊的，她一般都是长文，字很多，图为并茂的那种，基本是每个菜品配图，配评论，然后总结一下服务、环境、价格、推荐指数等等。这样细致的点评也难怪经常被人点赞，经常被商家点赞。所以我要学习这种经常点评，总结的精神，就从现在开始吧。 因-&gt;果自从上一次搭建自己的博客是在17年的国庆假期，当时使用的是Jekyll,后来因为要调整的东西太多啦，就中途废止了。这次使用Hexo搭建了博客，感觉后者操作还是比较方便的，选用的主题也是自己比较中意的NexT。当然创建过程还算比较顺利的原因是得益于参考了很多先人的博客，多亏这个博客为我铺平道路，抱拳感谢~ 修改样式变得酷炫参考了这个博客，这位大神讲解的很细致，但是有几个点是不起效果的，而且因为我的版本是6.0.1 所以有些操作是不同的。 当然，经过仔细研究还是能解决的，毕竟也是研究代码的人，这个模板的套路摸清了就好搞啦~ 需要有点耐心奥。 搞了一晚上的样式，，有些已经实现，但是还有些不太完美，只能后续再进行了。 TODO List: 在线沟通 邀请码：0f81ff2f Travis CI 自动发布 参考链接：传送门 友情链接、图片文章 参考链接：传送门 附加今日发现的好玩的网站： easyicon ：一个图标网站。 JiaThis ：一个可以嵌入分享、评论、推荐按钮的功能的网站。 iissnan ：NexT作者的博客]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>个人记录</tag>
      </tags>
  </entry>
</search>
