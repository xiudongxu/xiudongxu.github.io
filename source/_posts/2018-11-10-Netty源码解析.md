---
title: Netty源码解析
date: 2018-11-10 12:23:00
tags: Netty
categories: 源码解析
copyright: false
---

[NIO相关](https://www.cnblogs.com/java-zhao/p/9195943.html)

netty的高性能体现在哪里：

- 多路复用通信
- 异步IO
- 零拷贝
- 内存池
- 高效的Reactor线程模型  单线程，多线程，主从Reactor多线程模型



直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆 中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调 用来分配内存。这主要是为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复 制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。

ByteBuffer的Javadoc 明确指出：“直接缓冲区的内容将驻留在常规的会被垃圾回收的堆 之外。”这也就解释了为何直接缓冲区对于网络数据传输是理想的选择。如果你的数据包含在一 个在堆上分配的缓冲区中，那么事实上，在通过套接字发送它之前，JVM将会在内部把你的缓冲 区复制到一个直接缓冲区中。

直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。如果你 正在处理遗留代码，你也可能会遇到另外一个缺点：因为数据不是在堆上，所以你不得不进行一 次复制





慕课网Netty课程学习笔记

2-2

服务端监听端口  NioEventLoop

一个连接 ：io 编程模型是 socket，nio 编程模型是 channel

业务逻辑处理是由pipeline将各个处理业务的channelHandler串联起来的

2-3 netty组件介绍





NioEventLoop 对应 java 的Thread   本质上就是启动两种线程  它同时做两个事情 接收连接 处理业务。 

run方法里面的select 就是server端接收连接的操作 和 client端拿到数据流的操作。 具体后面分析。

接收到连接后  调用 processSelectedKeys() 处理对应每一个连接



Channel 对应java的Socket  它对java socket的封装

processSelectedKeys 里面的  unsafe.read() 对应两个实现类 一个是  NioByteUnsafe 是client端的数据流读写。

NioMessageUnsafe 对应的是 server端接收连接的 -> doReadMessage(readbuffer)  ->NioServerSocketChannel

里面能看到对应java底层的 socketChannel 就是 java 的 ServerSocketChannel   把这个封装成 netty 里面的  NioSocketChannel   最后基于  这个nsc 进行数据的读取的写入



ByteBuffer 对应数据的读写  

Pipeline  -> Logic Chine  什么时候把pipeline 加入到每个channel 的处理过程的？  在NioSocketChannel 的构造方法中可以找到答案。  每一个channle 都会有一个pipeline  然后把 逻辑链路 加到channel 里面

channel 每一次 对数据流的读写 都会经过pipeline



ChannelHandler -> Logic  逻辑处理块   ChannelHandler 是 加在 pipeline 里面的



3-2 netty 服务端启动

问题1：服务端的socket在哪里初始化。

问题2：在哪里accept连接。

总共分4步：

1.创建服务端channel  

2.初始化服务端channel

3.注册selector   把jdk 的底层的channel注册到selector上 并把 NioServerSocketChannel  attach 到 jdk的channel上

这样后续 selector 出事件之后 就能  拿到attachement  就能拿到  netty 封装的channel 

4.端口绑定 调用 jdk 底层的绑定API



1.1  bind() [用户代码入口]

​	initAndRegister()[初始化并注册]

​		newChannel()[创建服务端channel]



创建服务端channel 就是调用  bootStrap.channel(NioServerSocketChannel); 这个类进行反射 也就是要看构造函数

反射创建服务端Channel（这里思考为什么要用反射？ 因为你要提供给别人去用  别人传的类可能不同  new 相当于提前写死了要创建的类   就不能动态加载了）

new Socket[通过 jkd来创建底层jdk channel]

NioServerSocketChannelConfig()[tcp参数配置类]

AbstractNioChannel()	

​	configureBlocking(false)[阻塞模式]

​	AbstractChannel()[创建id,unsafe,pipeline]

2.1  接着上面 1.1 的 newChannel 后面    init() 初始化服务端channel

init()[初始化入口]   保存用户自定义的属性，创建一个连接接入器  就是把这些东西都给赋值上去

​	set ChannleOptions,ChannelAttrs

​	set ChildOptions,ChildAttrs  【每次新创建一个连接 都会把这两个属性配置上去】

​	config handler [配置服务端pipeline]

​	add ServerBootstrapAcceptor[特殊的处理器 把accept到的连接 分配一个Nio线程]



3.1 注册selector  initAndRegister   调用到   config().group().register(channel);

AbstractChannel  register()[入口]

​	this.eventLoop = eventLoop[绑定线程]

​	register0()[实际注册]

​		doRegister()[调用jdk底层注册]

​		invokerHandlerAddedIfNeeded(); 触发回调

​		fireChannelRegister()[传播事件:把注册成功传递到用户代码里面去] 

4.1 AbstractUnsafe.bind()[入口]

​	doBind()

​		javaChannel().bind()[jdk底层绑定]

​	pipeline.fireChannelActive()[传播事件]

​		HeadContext.readIfIsAutoRead();  将之前注册到select上的事件 重新绑定为一个 accept事件  



4.1 NioEventLoop概述

问题三个：

1.默认情况下，Netty服务端起多少线程？何时启动？

2.Netty 是如何解决jdk空轮训bug？

3.Netty 是如何保证异步串行无锁化？

NioEventLoop创建、启动、执行逻辑。

4.2 NioEventLoop创建  ->   MultithreadEventExecutorGroup

newNioEventLoopGroup[线程组，默认2*cpu]

​	new ThreadPerTaskExecutor()[线程创建器]

​	for(){newChild()}[构造NioEventLoop]

​	chooserFactory.newChooser()[线程选择器]

```java
public NioEventLoopGroup(int nThreads, Executor executor){
    this(nThreads, executor, SelectorProvider.provider());
}
```

4.3 ThreadPerTaskExecutor  线程执行器

- 每次执行任务都会创建一个线程实体
- NioEventLoop线程命名规则nioEventLoop-1-xx    -1 指的是第几个nioEventLoopGoup  -xx 指的是第几个nioEventLoop

重点：netty 底层的thread 不是java 原生的thread 而是经过包装的FastTreadLocalThread(threadGroup , r , name);

4.4 创建NioEventLoop线程  

newchild()

- 保存线程执行器ThreadPerTaskExecutor
- 创建一个MpscQueue
- 创建一个selector

一个selector 和 一个nioEventLoop 做绑定

来到 NioEventLoop 构造函数的父类构造函数  

taskQueue = newTaskQueue  return  PlatformDependent.newMpscQueue(maxPendingTasks);

new Mulity Producer  Single Consumer Queue

4.5 chooserFactory.newChooser();  创建chooser 给新连接绑定对应的EventLoop

对应的就是 MultithreadEventExecutorGroup 的 next  方法。 调用chooser.next();

对应一个NioEventLoop[] 数组  从头开始绑定  一个连接对应一个  超出就从头再来。



创建chooser   chooserFactory.newChooser();

isPowerOfTwo()[判断是否是2的幂 如 2、4、8、16]

​	PowerOfTwoEventExecutorChooser[优化]

​		index++ &( length - 1 )

​	GenericEventExecutorChooser[普通]

​		abs(index++ % length)

4.6  NioEventLoop 启动  

bind() -> execute(task)[入口]

​	startThread() -> doStartThread()[创建线程]

​		ThreadPerTaskExecutor.execute()  每次执行任务都会创建一个线程

​			thread = Thread.currentThread(); 将此线程进行保存  创建fastThreadLocalThread

​			NioEventLoop.run(); 启动

**问题： channel 和 eventLoop 什么关系？**

进度：2019年04月17日08:53:06  视频4-6 

4.7 NioEventLoop 执行

SingleThreadEventExecutor.this.run(); 

NioEventLoop.run();

​	run() -> for(;;)

​		select()[检查是否有io事件]

​		processSelectedKeys()[处理io事件]

​		runAllTasks()[处理异步任务队列]

一个nioEventLoop 对应一个selector  轮训注册到这个selector上的io事件

4.8 select()方法执行逻辑

- deadline以及任务穿插逻辑处理
- 阻塞式select
- 避免jdk空轮训的bug

4.8.1 select   wakenUp 标记这个select 是不是唤醒状态。

NioEventLoop 底层会有一个定时任务队列（后面会讲到）

如果超时的话  会直接执行一次 **非阻塞的selector.selectNow()**  如果没有到超时时间的话

阻塞1s进行一个select事件  并把计数++ 



如果没有阻塞 就立即返回了 这样就是空轮训  空轮训次数 大于一个阈值  512 

会rebuildSelector() 方法  把老的selctor的key 注册到新的 selector上去











































