---
title: 生产者消费者
date: 2018-04-22 17:22:41
tags: 多线程
categories: JAVA学习
---

最近看了马士兵老师讲的并发课程，讲到这个例子的时候提出两个问题，现在自己经过反思消化，记录下来。

<!-- more --> 

```java
import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

/**
 * Description:一个普通的生产者和消费者的例子
 * @author xiudongxu
 * @date 2018/4/22
 */
public class ProducerAndConsumer {

    final private LinkedList list = new LinkedList(); //存储容器
    final private int MAX = 10; //元素最大个数
    private int count = 0;

    public synchronized void put(Object obj){
        //问题1：这里为啥用while而不是if
        //假设有两个线程t1,t2在同时在wait处等待，而且容器此时突然有了一个空位置，而且已经被刚刚消费了的线程使用notifyall()唤醒了，
        //t1，t2接收到唤醒操作时，同时去获取对象锁，此时假设t2获取成功了。t2 添加一个元素，此时容器满了，t2线程使用notifyall唤醒t1线程。
        //t1去获取对象锁，从this.wait()处继续执行代码。如果此时使用的是if 那么就出问题了，t1直接执行add操作，导致容器超出容量，报错。
        //而如果是while循环的话，那么还会进行一次list.size() == MAX 判断。
        //判断结束t1 又会wait 而释放锁。等待被唤醒添加元素。
        //这样就不会出问题了。

        //当然以上描述比较复杂，是因为要出现这种错误的话，需要天时地利人和，
        //但是这种极端的情况又必须要考虑好，才能保证万无一失。所以说这个经典问题是值得反复推敲的。
        //而且《effective java》 中也说到 一般wait都要与while配合使用，如果不懂就记住。
        while (list.size() == MAX){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        list.add(obj);
        ++count;
        //问题2：为何用notifyall 而不是 notify
        //注：唤醒  是指线程的状态 从等待的状态变成就绪的状态。
        //假设此时是有一个生产者线程，一个消费者线程在等待的状态。
        //如果使用notify 唤醒的是一个生产者线程。那么就死锁等待了。所有的线程都是等待状态就死锁了。
        //如果是notify 唤醒的是所有线程，即使是一个生产者线程，那么生产者线程等待失去锁的时候，消费者线程从就绪态获得锁会继续执行消费，而不是程序进入死锁的状态。
        this.notifyAll();
    }

    public synchronized Object get(){
        Object obj = null;
        while (list.size() == 0){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        obj = list.removeFirst();
        -- count;
        this.notifyAll();
        return obj;
    }

    public static void main(String[] args) {
        ProducerAndConsumer pandc = new ProducerAndConsumer();
        //启动消费者线程
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                for (int j = 0; j < 5; j++) {
                    System.out.println(pandc.get());
                }
            },"consumer" + i).start();
        }
        //睡一会
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //启动生产者线程
        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                for (int j = 0; j < 25; j++) {
                    pandc.put(Thread.currentThread().getName() + " " + j);
                }
            },"producter" + i).start();
        }
    }
}

```
