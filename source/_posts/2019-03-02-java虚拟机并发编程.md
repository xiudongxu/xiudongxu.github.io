---
title: java虚拟机并发编程
date: 2019-03-02 23:40:20
tags: java虚拟机并发编程
categories: 看书总结
copyright: false
---

最多的是下面三种并发模型：

- 同步并受罪 模型
- 软件事务内存模型（Software Transactional Memory STM）
- 基于角色的并发模型（actor-based）

有以下三个方法能够帮助我们避免并发所带来的问题

- 在合适的地方进行正确的同步
- 不共享状态
- 不改变状态

**消除显示锁来降低复杂性和出错概率的类库等方面的内容**

并发应用程序常见的三个问题：

- 饥饿   一般设置超时时间来避免这个问题 跳出等待 然后再继续执行
- 死锁   两个线程相互等待对方释放所占用的资源或执行某些动作   超时时间是无法避免死锁问题的。 虽然可以用Jconsole 的工具来查看是否发生了死锁，但还是建议避免显示加锁以及避免使用可变状态
- 竞争条件  表示两个线程竞争使用相同的资源或数据。发生在两个线程同时修改一个资源或者一个线程修改而另一个线程读取资源的情况。

竞争条件的产生原因 一般是由以下两个问题产生的  JIT编译器的优化和java内存模型。

JIT编译器 对while循环进行了优化 导致新线程在上下文中无法看到变量done的变化

比如设置一个 done 变量 来终止一个循环  必须是volatile 的否则可能一直循环下去。

内存栅栏就是 从本地内存到主存之间的拷贝动作，仅当写操作线程先跨越内存栅栏而读线程后跨越内存栅栏的情况下，写操作线程所做的变更才对其他线程可见



获取核心数量 Runtime.getRuntime().availableProcessors();

如何计算所需要的线程数   所需线程数 = 核心数 / ( 1 - 阻塞系数 )



不只是计算所需要的线程数   子任务的划分也很重要   子任务的划分数量应不小于核心线程数



## 第三章 设计方法

我们无法避免操纵状态，

保证共享数据是不可变的 可变数据是隔离的 那么就线程安全了

使用invokeAll() 函数 来执行一组任务的调度



数据交换

我们经常需要在相互协作的线程之间交换数据，  future  blockingqueue 阻塞队列就是专门处理线程之间交换数据的。



如果想使  插入和删除操作一一对应的话   使用SynchronousQueue  类似手递手形式的数据传输。

## 第五章 驯服共享可变性

如果对共享变量未进行保护 则会 出现 变量可见性问题和竞争条件。

可见性问题就是  由于我们并未强制要求线程在访问变量时一定要穿越内存栅栏，所以调用这些值的线程可能无法及时看到level值的变化。

在构造函数中启动线程 是一个糟糕的设计

为了保持不变式  请不要在构造函数中 创建线程