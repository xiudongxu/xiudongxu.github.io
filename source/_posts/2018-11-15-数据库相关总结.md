---
title: 数据库相关总结
date: 2018-11-15 19:31:50
tags: 锁和隔离级别
categories: DB-Mysql
copyright: false
---

[Innodb](http://blog.itpub.net/7728585/viewspace-2146183/)

[数据库的隔离级别以及悲观锁和乐观锁详解](https://blog.csdn.net/xiaokang123456kao/article/details/75268240)

[Innodb中的事务隔离级别实现原理](https://www.cnblogs.com/Genesisx/p/9139175.html)

[mysql innodb如何在RR级别下防止幻读](https://www.jianshu.com/p/2953c64761aa)



mysql有一个autocommit参数，默认是on，他的作用是每一条单独的查询都是一个事务，并且自动开始，自动提交（执行完以后就自动结束了，如果你要适用select for update，而不手动调用 start transaction，这个for update的行锁机制等于没用，因为行锁在自动提交后就释放了），所以事务隔离级别和锁机制即使你不显式调用start transaction，这种机制在单独的一条查询语句中也是适用的，分析锁的运作的时候一定要注意这一点。



### 一个mysql死锁现象的发生

mysql 有一种发生死锁的情况 和 解决办法， 掘金上也有文章  挖坑的张师傅

如果用到了非主键索引，msyql会先锁定非主键索引，再锁定主键索引。

如果两条sql执行间隔时间非常短的话，会出现资源争夺的情况，可能死锁，

做update的话，（并发量高的情况？）先把update的数据先条件查询出来，再做主键id的更新